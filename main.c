/*
 * testSD.c
 *
 * Created: 7/6/2016 3:18:04 PM
 * Author : BurNing
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include <string.h>
#include <stdio.h>

#include "ff.h"		/* Declarations of FatFs API */
#include "diskio.h"


FATFS FatFs;		/* FatFs work area needed for each volume */
FIL Fil;			/* File object needed for each open file */

volatile FRESULT test = 0;
uint16_t data = 0, i= 0;

char* str;

void clock_init(void);
void tc0_init(void);

DWORD get_fattime (void){
		/* Pack date and time into a DWORD variable */
		return	  ((DWORD)(2013 - 1980) << 25)
		| ((DWORD)3 << 21)
		| ((DWORD)23 << 16)
		| ((DWORD)12 << 11)
		| ((DWORD)0 << 5)
		| ((DWORD)0 >> 1);
}

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC0A                 */
/*---------------------------------------------------------*/


ISR(TCC0_OVF_vect)
{
	//might still work without this
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}



int main(void)
{
	//PORTD.OUT=0x10;
	//PORTD.DIR=0xB0;
	PORTD.PIN6CTRL = PORT_OPC_WIREDANDPULL_gc;

	cli();
	clock_init();
	tc0_init();

	// SPID interrupt: Disabled
	SPID.INTCTRL = SPI_INTLVL_OFF_gc;

	sei();

	UINT bw;
	//should be enclosed by cli() and sei()
	f_mount(0, &FatFs);		/* Give a work area to the default drive */
	/* Create a file */
	if (f_open(&Fil, "newfile.txt", FA_WRITE | FA_OPEN_ALWAYS) == FR_OK){
		if (f_lseek(&Fil, f_size(&Fil)) != FR_OK)
		f_close(&Fil);
	}
	f_sync(&Fil);

	/* Replace with your application code */
	while (1)
	{
		sprintf(str, "%d Test \r\n", i++);
			
		f_write(&Fil, str, strlen(str), &bw);	/* Write data to the file */
		f_sync(&Fil);
		//f_close(&Fil);
	}
}

void clock_init(void){
	uint8_t n;
	// Enable the internal 32 MHz RC oscillator
	OSC.CTRL|=OSC_RC32MEN_bm;
	// Wait for the internal 32 MHz RC oscillator to stabilize
	while ((OSC.STATUS & OSC_RC32MRDY_bm)==0);

	// System Clock prescaler A division factor: 1
	// System Clock prescalers B & C division factors: B:1, C:1
	// ClkPer4: 32000.000 kHz
	// ClkPer2: 32000.000 kHz
	// ClkPer:  32000.000 kHz
	// ClkCPU:  32000.000 kHz
	n=(CLK.PSCTRL & (~(CLK_PSADIV_gm | CLK_PSBCDIV1_bm | CLK_PSBCDIV0_bm))) |
	CLK_PSADIV_1_gc | CLK_PSBCDIV_1_1_gc;
	CCP=CCP_IOREG_gc;
	CLK.PSCTRL=n;

	// Select the system clock source: 32 MHz Internal RC Osc.
	n=(CLK.CTRL & (~CLK_SCLKSEL_gm)) | CLK_SCLKSEL_RC32M_gc;
	CCP=CCP_IOREG_gc;
	CLK.CTRL=n;
}

void tc0_init(void){
	// Clock source: ClkPer/256
	TCC0.CTRLA=TC_CLKSEL_DIV256_gc;
	// Mode: Normal Operation, Overflow Int./Event on TOP
	// Compare/Capture on channel A: Off
	// Compare/Capture on channel B: Off
	// Compare/Capture on channel C: Off
	// Compare/Capture on channel D: Off
	TCC0.CTRLB=(0<<TC0_CCDEN_bp) | (0<<TC0_CCCEN_bp) | (0<<TC0_CCBEN_bp) | (0<<TC0_CCAEN_bp) |
	TC_WGMODE_NORMAL_gc;
	// Capture event source: None
	// Capture event action: None
	TCC0.CTRLD=TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;

	// Set Timer/Counter in Normal mode
	TCC0.CTRLE=(0<<TC0_BYTEM_bp);

	// Overflow interrupt: Enabled
	// Error interrupt: Disabled
	TCC0.INTCTRLA=TC_ERRINTLVL_OFF_gc | TC_OVFINTLVL_LO_gc;

	// Clear the interrupt flags
	TCC0.INTFLAGS=TCC0.INTFLAGS;
	// Set Counter register
	TCC0.CNT=0x0000;
	// Set Period register
	TCC0.PER=1250-1;
	
}